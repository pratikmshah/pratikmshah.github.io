---
title:  "Java Reference"
date:   2017-06-14
image: "/java/java.jpg"
---
Java is a high-level programming language that can run java applications on any operating system via the java virtual machine (JVM). Its signature phrase "Write Once, Run Anywhere". Java is also the underlying language for the Android OS. The Java syntax is similar to C-style languages such as: C, C++, JavaScript. Although Java is slower in speed than the other languages the best feature of Java is that is dynamically manages memory for you. If you can learn and understand the Java language then learning other languages will be a walk in the park.

<br>

### Table of Contents
 1. [Intro](#intro)
 - [Resources](#resource)
 - [CLI Compile & Run](#cli-compile-run)
 - [Memory Management](#memory)
 2. [Data Types](#data-types)
 - [Declare and Initialize Variables](#variables)
 - [Numbers](#numbers)
 - [Convert Numbers](#cnumbers)
 - [Operators](#operator)
 - [Characters](#char)
 - [Booleans](#bool)
 - [Strings](#str)
 3. [Control Flow](#ctrl)
 - [Conditionals](#condition)
 - [Switch Statement](#switch)
 - [Loops](#loop)
 - [Method](#method)
 4. [Complex Data Types](#com-data)
 - [String Class](#str-class)
 - [Date Class](#date)
 5. [Exception Handling](#exception)
 - [Try-Catch](#try-catch)
 6. [Data Collections](#collection)
 - [Arrays](#array)

<br>

### Intro <a name="intro"></a>
#### Resources <a name="resource"></a>
  - [Java Home](http://www.oracle.com/technetwork/java/index.html)
  - [Eclipse IDE](https://eclipse.org/)
  - [API Docs](http://www.oracle.com/technetwork/java/javase/documentation/api-jsp-136079.html)

<br>

#### CLI Compile & Run <a name="cli-compile-run"></a>
To compile your java class you need to navigate using your console to the `src` directory. You then need to compile your java class using `javac Name.java` and Java is case sensitive. Then to run the compiled app you use `java Name` without the .class.

To view a list of all the `javac` commands type `javac` to view the entire list. If you want to see what java compiler is doing in the background use the `-verbose` command and it will list every action being done while compiling.


<figure>
  <img src="/img/posts/java/javac.png" class="blg-img" alt="java compile">
  <figcaption>Compile from command line</figcaption>
</figure>

<figure>
  <img src="/img/posts/java/javar.png" class="blg-img" alt="java run">
  <figcaption>Run from command line</figcaption>
</figure>

<br>

#### Memory Management <a name="memory"></a>
Java manages memory usage automatically using the garbage collector. When you create an object they are stored in heap memory and as long as the variable references an object it is retained.

Variables expire in 2 ways. The first is if you are running a code block in which a variable is created then after the block has been executed then the variable that was created can be destroyed. The second way is for you to assign the variable to `null`.

The garbage collector has its own set of algorithm to identify when to destroy and reclaim memory. You as the developer can design your program to use the least amount of memory as possible. If you need to know the amount of memory available use the below methods to assist.

  - Runtime.maxMemory()
  - Runtime.totalMemory()
  - Runtime.freeMemory()

<br>

### Data Types <a name="data-types"></a>
Everything in Java is an object. Each data type has their own class for example: strings have their own class called String with several useful methods that can be used. Each time you create a data type you are creating an instance of a class.

<br>

#### Declare and Initialize Variables <a name="variables"></a>
There are two types of variables that Java has. Primitives are stored in fast memory and are Integers, Floats, Chars, or Booleans. The other data type is complex objects which can be Strings, Dates and everything else.

To declare a primitive data type in Java you need to 3 things.
  - Data Type
  - Variable Name
  - Value (optional)

``` java
// data type - variable name = value
int myVar = 15;
```
To declare objects you also need to 3 things and the `new` keyword.

``` java
// data type class - variable name = initial value from constructor
Dog fido = new Dog();
```

You can declare variables inside a function or outside which will change the variable's scope visibility. If you declare it inside the function the variable can only be used inside the function. If it is declared outside then it is a class/field variable and can be used everywhere.

<br>

#### Numbers <a name="numbers"></a>
A primitive data type has only one value and cannot hold complex objects such as strings.

<table class="table">
  <thead>
    <tr>
      <th>Data Type</th>
      <th>Bits</th>
      <th>Minimum</th>
      <th>Maximum</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>byte</td>
      <td>8</td>
      <td>-128</td>
      <td>127</td>
    </tr>
    <tr>
      <td>short</td>
      <td>16</td>
      <td>-32,768</td>
      <td>32,767</td>
    </tr>
    <tr>
      <td>int</td>
      <td>32</td>
      <td>-2,147,483,648</td>
      <td>2,147,483,647</td>
    </tr>
    <tr>
      <td>long</td>
      <td>64</td>
      <td>-9.22337E+18</td>
      <td>9.22337E+18</td>
    </tr>
    <tr>
      <td>float</td>
      <td>32</td>
      <td class="text-center" colspan="2">See documentation</td>
    </tr>
    <tr>
      <td>double</td>
      <td>64</td>
      <td class="text-center" colspan="2">See documentation</td>
    </tr>
  </tbody>
</table>

<br>

``` java
/* PRIMITIVE DATA TYPES */

byte b = 2;

short s = 15;

int i = 100;

/*
 L, f and d should be included else the value will be cast from byte short int to long, float or double causing more memory to be used.
*/

long l = 1000L;

float f = 125.75f;

double d = 125.5d;
```

You can access each primitive value's helper class which is typically the data type with the first letter being capitalized ex: `byte -> Byte`. Only exception is `int -> Integer`.

If you are doing big computational or currency and need precision then you need to use the `BigDecimal` class. Create the `BigDecimal` object from a string or else you will have floater values and will lose precision.

``` java
// create BigDecimal object
double d = 123.45;
String dStr = Double.toString(d);
BigDecimal bigDec = new BigDecimal(dStr);
System.out.println(bigDec.toString());
```
<br>

#### Convert Numbers <a name="cnumbers"></a>
The primitive data types from the smallest to the largest memory usage and value storage are:
 - byte
 - short
 - int
 - long
 - float
 - double
You can implicitly convert a number upwards from short to int to long by assigning the value of the smaller type to the bigger one.

``` java
int i = 15;           // 15
long longUpcast = i;  // 15.0
```

If you want to convert downwards then you need to explicitly tell the compiler via typecast. An alternative is to use a helper class method from the class of the type.

``` java
// typecasting
double dubVal = 15.74;      
int intDowncast = (int)dubVal;

// helper class
double dValue = 5.55;
double doubleObject = new Double(dValue);
int i = doubleObject.intValue();
```
<br>

#### Operators <a name="operator"></a>
There are several types of operators that allow you to manipulate and evaluate expressions.
 - assignment
 - equality/relational
 - mathematical
 - conditional
 - ternary

 The assignment operator `=` is used to assign a value from the right to the data type on the left ex: `int i = 5;`

 Math operators are similar to how they are in other languages.
  - addition `+` ex: `int x = 15 + 5;`
  - subtraction `-` ex: `int x = 15 - 5;`
  - multiplication `*` ex: `int x = 15 * 5;`
  - division `/` ex: `int x = 15 / 5;`
  - modulus `%` ex: `int x = 11 % 5;` will give remainder
  - increment `++` ex: `x++;` will increment by 1
  - decrement `--` ex: `x--;` will decrement by 1
  - postfix `x++` will evaluate x then increment by one
  - prefix `++x` will increment x by one and then evaluate x
  - short addition `+=` ex: `i += 5` will take value of i and add 5
  - short subtraction `-=` ex: `i -= 5` will take value of i and subtract 5
  - short multiplication `*=` ex: `i += 5` will take value of i and multiply 5
  - short division `/=` ex: `i /= 5` will take value of i and divide 5

  Equality or Relational Operators
  - `>` greater than
  - `<` less than
  - `>=` greater than or equal to
  - `<=` less than or equal to
  - `==` equal to (not strick)
  - `===` equal to and same class type
  - `!=` not equal to
  - `!false` changes false to true
  - `&&` both sides must evaluate to true
  - `||` at least one side must evaluate to true
  - `instanceof` Class membership ex: `str instanceof java.lang.String`

<br>

#### Characters <a name="char"></a>
You can work with single characters by using the primitive data type of `char`. To assign variable to a single character you must use single quotes. You can also assign [unicode](https://en.wikipedia.org/wiki/List_of_Unicode_characters) to characters. You can use the `Character` class to find helper methods.

``` java
public class Main {
  public static void main(String[] args) {
    char chr1 = 'a';
    char chr2 = 'A';
    char chr3 = '3';
    char pound = '\u00A3';

    System.out.println(chr1);
    System.out.println(chr2);
    System.out.println(chr3);
    System.out.println(pound);

    char chr4 = 'y';

    System.out.println(Character.toUpperCase(chr4));    

  }
}
```
<br>

#### Booleans <a name="bool"></a>
Booleans are `true` or `false` values thats it. Use the `Boolean` class in order to use helper methods.

``` java
public class Main {
  public static void main(String[] args) {
    boolean x = true;
    boolean y = false;
    System.out.println(x);  // prints true    
    System.out.println(y);  // prints false

    boolean b = !x;
    System.out.println(b);  // prints false

    int i = 5;
    boolean num = (i != 3);
    System.out.println(num); // prints true   

  }
}
```
<br>

#### Strings <a name="str"></a>
Java can print any number type as a string which it automatically does when using the print or println. In Java it doesn't matter if you concatenate and begin the expression with a number because if there is one string involved the entire expression becomes a string. Every object in Java has a `toString()` method. So if you were concatenating an object to a string it would call its `toString()` method.


``` java
import java.util.Date;

public class Main {
  public static void main(String[] args) {
    int i = 1421313;
    double d = 3.14;

    System.out.println(i);   
    System.out.println(d);

    System.out.println(1 + " string " + 5);  

    Date today = new Date();
    System.out.println("The date is " + today);

  }
}
```
<br>

### Control Flow <a name="ctrl"></a>

#### Conditionals <a name="condition"></a>
Use the keyword `if` to control the flow of the program. The syntax is `if (condition)` followed by a code block. You can also add in the additional keywords `else if` and `else` for multiple condition checks. If you are comparing strings you will need to use methods from the string class to compare ex: `equals(str)` `str.equals(str2)`.

``` java
public class Main {
  public static void main(String[] args) {
    int i = 5;

    if (i == 5) {
      System.out.println("Excellent Rating!");
    }
    else if (i < 5 && i > 2) {
      System.out.println("Good but not great.");
    }
    else {
      System.out.println("Junk Rating");
    }
  }
}
```
<br>

#### Switch Statement <a name="switch"></a>
Use switch statements to evaluate a single int, byte, short, enum and string (Java 7 only). Use the `switch`, `case`, `break`, and `default` keywords. The `break` keyword is used to exit a code block. You can also use `enum` which are a list of constants and good to pair with switch statements.

``` java
// switch structure
switch (key) {
  case value:

    break;

  default;
    break;
}
```

``` java
import java.util.Scanner;

public class Main {
  public static void main(String[] args) {
    Scanner input = new Scanner(System.in);
    System.out.print("Rate this ad with a # between 1 - 5: ");
    int rate = input.nextInt();

    switch (rate) {
      case 5:
        System.out.println("Excellent");
        break;
      case 4:
        System.out.println("Great");
        break;
      case 3:
        System.out.println("Average");
        break;
      case 2:
        System.out.println("Poor");
        break;
      case 1:
        System.out.println("Bad");
        break;
      default:
        System.out.println("Out of range select between 1 - 5");
        break;
    }
  }
}
```
``` java
// enum example
public class Main {

  public enum Days {
    Monday, Tuesday, Wednesday, Thursday, Friday, Saturday, Sunday
  }

  public static void main(String[] args) {

    Days day = Days.Tuesday;

    System.out.println(day.Thursday);
  }

}
```

<br>

#### Loops <a name="loop"></a>
There are several types of loops that can be helpful repeating the same code over and over or loop through and array. When creating loops you need to make sure that there will be a point in time when the condition returns false or else you will have an infinite loop.

The `for` loop consists of three parts: `for (int i = 0; i < 10; i++)`. The first is a counter variable. The second is the comparison that when return false will exit the loop. The last is an increment to the counter variable.

The `for each` loop is used to loop through an entire array or hash once ex: `for (Integer day : days)`.

The `while` loop checks the condition first then runs the code ex: `while (x != 0)`.

The `do while` loop runs the code at least once and then checks the condition ex: `do { code } while (x != 0);`.

``` java
public class Main {

  public static void main(String[] args) {
    int[] data = { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 };

    // For Loop
    for (int i = 0; i < data.length; i++) {
      System.out.println(data[i]);
    }

    // For Each
    for (Integer num : data) {
      System.out.println(num);
    }

    // While Loop
    int  i = 0;
    while (i < data.length) {
      System.out.println(data[i]);
      i++;
    }

    // Do While Loop
    int j = 0;
    do {
      System.out.println(data[j]);
      j++;
    } while (j < data.length);

  }
}
```
<br>

#### Methods <a name="method"></a>
Methods are equivalent to functions like in other languages. They are called methods because in OOP functions or an object are called methods and everything in Java is an object. Methods are good to create if you see yourself running the same code over and over again. Every method must be defined within a class. The one method you always see is `public static void main(String[] args)`.

There are three types of methods you can create: `public`, `private`, `protected`.
  - public - method is available to the entire program as long as it can access it.
  - private - method is only available to the class it is in.
  - protected - method is available to the class and its inherited class.

The `static` keyword means that the method is a class method vs an instance method. Static methods can call other static methods and instance methods can call other instance methods.

Next you declare the return type if you are returning a data type else just put `void`. After you name the method using camel case followed by parentheses with optional arguments: `myMethod()`.

``` java
public class Main {

  public static void main(String[] args) {
    saySomething();
  }

  private static void saySomething() {
    System.out.println("You just ran this method.");
  }

}
```

When creating your own method you have the option to allow it to pass in arguments. If you take in arguments you must specify the data type of the argument.

``` java
public class Main {

  public static void main(String[] args) {
    System.out.println(add(5, 7));
  }

  // returns double and takes in 2 double arguments
  private static double add(double x, double y) {
    return x + y;
  }

}
```
If you do not know how many arguments may come through you can use the `...` to tell Java that there might be multiple values that are passed in ex: `multiple(double ... values)`. Java will build an array of all the arguments passed.

``` java
public class Main {

  public static void main(String[] args) {
    System.out.println(add(5, 7, 12, 3, 4));
  }

  // returns double and takes in multiple double arguments
  private static double add(double ... numbers) {
    double sum = 0d;
    for (double n : numbers ) {
      sum += n;
    }
    return sum;
  }

}
```
Method signature is the unique combination of the keywords and arguments that method receives. You can create multiple methods with the same name as long as the signatures are different. Creating multiple same named methods is called method overloading.

``` java
public class Main {

  public static void main(String[] args) {

    // run first add method with 2 args
    System.out.println(add(5, 7));

    // run second add method with 3 args
    System.out.println(add(5, 7, 12));

    // run third add method with 2 strings
    System.out.println(add("15", "13"));
  }

  // returns double and takes in 2 double arguments
  private static int add(int x, int y) {
    return x + y;
  }

  private static int add(int x, int y, int z) {
    return x + y + z;
  }

  private static int add(String one, String two) {
    int val1 = Integer.parseInt(one);
    int val2 = Integer.parseInt(two);
    return val1 + val2;
  }

}
```

When passing variables as arguments they are always passed by copy. Passing by copy means that a copy of the variable is passed through and not the variable itself. Passing by reference means that the original variable itself is being altered.
Complex objects are references. A reference variable points to the location in memory. When you pass the variable into a method a new reference is created but both of these are pointing to the original object. Strings cannot be changed and are immutable so when passing in a string and altering it you are simply creating another string.

<br>

### Complex Data Types <a name="com-data"></a>
#### String Class <a name="str-class"></a>
There are plenty of helpful methods to be used in the string class. You can create a string by using the string class ex: `String str = new String("My string goes here");`.

If you need to compare two strings and case matters you need to use the `equals(str)` method or else you can use the `equalsIgnoreCase(str)` method. The `toCharArray()` splits each character into an element via array.

``` java
public class Main {

  public static void main(String[] args) {

    // string literal
    String str1 = "This is literal";

    // string via String constructor
    String str2 = new String("Create string via string class");

    System.out.println(str2);

    // use .equals method to compare two strings and case matters
    // use .equalsIgnoreCase method to compare two strings without case sensitivity.
    String s1 = "this";
    String s2 = "this";
    String s3 = "THIS";

    if (str1.equals(str2)) {
      System.out.println("matches");
    }
    else {
      System.out.println("no match");
    }

    char[] characters = s3.toCharArray();
    for (char c : characters) {
      System.out.println(c);
    }

  }
}
```
Strings are immutable and cannot be concatenated. You can use the `StringBuilder` or `StringBuffer` to append, prepend or insert string.

``` java
public class Main {

  public static void main(String[] args) {
    String str = "I want to go to ";
    StringBuilder strbuild = new StringBuilder(str);

    strbuild.append("California!");

    System.out.println(strbuild);
  }
}
```

To find out the length of a string use the `.length()` method. You can find out where a particular character or string starts using the `indexOf(letter)` method. To extract a range of the string use the `substring(index#)` method. To get rid of whitespace use the `trim()` method.

``` java
public class Main {

  public static void main(String[] args) {
    String str = "This is a test string";

    // use the length method to get the length of a string
    System.out.println(str.length());

    // use the indexOf method to return the first index pos of the matched string
    System.out.println(str.indexOf("a"));

    // extract a range of the string use substring
    System.out.println(str.substring(5));

    // trim all the surrounding whitespace by using trim method
    String str1 = "whitespace      ";
    System.out.println(str1.trim());
  }
}
```
<br>

#### Date Class <a name="date"></a>
The `Date` class is part of the java.util package and must be imported. You can have the date in Gregorian Calender by using the `GregorianCalender` class.

``` java
import java.util.Date;
import java.text.DateFormat;
import java.util.GregorianCalendar;

public class Main {

  public static void main(String[] args) {
    Date date = new Date();

    // standard no arguments output
    System.out.println(date);

    // gregorian calender
    GregorianCalendar gc = new GregorianCalendar(2015, 4, 25);

    // increment the day by one
    gc.add(GregorianCalendar.DATE, 1);

    // get full date string version with time
    Date d2 = gc.getTime();

    // returns the date in month, day, year format
    DateFormat df = DateFormat.getDateInstance();
    String strDate = df.format(d2);

    System.out.println(strDate);
  }
}
```
### Exception Handling <a name="exception"></a>
#### Try-Catch & Throw <a name="try-catch"></a>
If you know a runtime error may occur you can handle them using `try` and `catch`. When an exception occurs then an exception object is created which you can use to display the errors.

``` java
public class Main {
  public static void main(String[] args) {
    try {
      String[] str = {"Illinois"};
      System.out.println(str[1]);
    } catch (Exception e) {
      e.printStackTrace();
      System.out.println("Custom messages can be written.");
    }

    System.out.println("Program handled exception and made it through.");
  }
}
```
You can declare `throws` for code that might have runtime exceptions.

``` java
public class Main {
  public static void main(String[] args) {
    try {
      returnArr();
    } catch (Exception e) {
      System.out.println("There was an array runtime error");
    }

    System.out.println("Program handled exception and made it through.");
  }

  private static void returnArr() throws ArrayIndexOutOfBoundsException {
      String[] str = {"Illinois"};
      System.out.println(str[1]);
  }
}
```
### Data Collections <a name="collection"></a>
#### Arrays <a name="array"></a>
Simple arrays are great for storing large sets of data but they are not flexible as you can only store one type of data type. They also cannot be resized once they are created; you need to use the `Array<list>` class.

You can create a simple array literal via 3 methods: `int[] arr = new int[3]`, `int arr[] = new int[3]`, `int[] arr = {1, 2, 3}`. To access data of the array specify the index between brackets (index starts at 0) use `arr[index#]`.

You can also create multi dimensional arrays by putting an additional set of brackets when instantiating: `double[][] arr = new Double[3][3]`

``` java
public class Main {
  public static void main(String[] args) {

    // create 5 by 2 array
    int[][] arr = new int[3][3];

    // access array by specifiying first column index then row.
    arr[0][0] = 1;
    arr[0][1] = 2;
    arr[0][2] = 3;
    arr[1][0] = 4;
    arr[1][1] = 5;
    arr[1][2] = 6;
    arr[2][0] = 7;
    arr[2][1] = 8;
    arr[2][2] = 9;

    // using a double for loop is best way to run through each row and column
    for (int i = 0; i < arr.length; i++) {
      for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j]);
      }
      System.out.println();
    }

  }
}
```

If you need dynamic amount of array size then you need to use Array Lists. To create an array list use: `ArrayList<int> arr = new ArrayList<int>()`. The `< >` are generics which means that this data will only carry a particular data type.

``` java
import java.util.ArrayList;

public class Main {
  public static void main(String[] args) {

    // create string list
    ArrayList<String> arr = new ArrayList<String>();

    // add items
    arr.add("Jack");
    arr.add("Jill");
    arr.add("John");

    System.out.println(arr);

    // remove items
    arr.remove(0);

    System.out.println(arr);

    // get item from list
    System.out.println(arr.get(1));

    // get index of and item
    System.out.println(arr.indexOf("Jill"));
  }
}
```
